# Smart Pointers

## `Box`和 `Deref`

### 1. Box<T> 智能指针

`Box<T>` 是 Rust 中最基础的智能指针之一,它允许你在**堆(heap)**上分配数据,而不是在栈(stack)上.

---

### 2. Box 的核心特点

- **所有权转移**:当我们将一个 `Box` 变量赋值给另一个变量时,所有权会发生转移.由于 `Box` 内部的数据存储在堆上,这种转移仅仅是复制 `Box` 指针本身,开销很小,而不是像栈上数据那样进行深拷贝.

- **示例**:

  ```rust
  // 在堆上创建一个长度为1000的数组
  let arr = Box::new([0; 1000]);

  // 所有权转移给 arr1,arr 不再拥有所有权
  let arr1 = arr;

  println!("{:?}", arr1.len());

  // 以下代码将报错,因为 arr 的所有权已转移
  // println!("{:?}", arr.len());
  ```

---

### 3. Deref Trait

`Deref` trait 是让智能指针像普通引用一样工作的关键.通过为自定义类型实现 `Deref` trait,你可以:

- 使用**解引用运算符 `\*`** 来访问智能指针内部的值.
- 让智能指针**自动借用**其内部数据,从而可以直接调用内部类型的方法.这种行为称为**解引用强制转换(Deref Coercion)**.

#### **`Deref` Trait 的实现**

- `type Target`:定义了解引用操作后返回的目标类型.
- `fn deref(&self) -> &Self::Target`:这个方法返回一个指向智能指针内部数据的引用.

---

### 4. 自定义智能指针 MyBox 和 Box\_

你提供的代码中定义了两个自定义的智能指针 `MyBox<T>` 和 `Box_<T>`,它们都是**元组结构体**,用于包装一个泛型值 `T`.

- **结构体定义**:

  Rust

  ```rust
  struct MyBox<T>(T);
  struct Box_<T>(T);
  ```

- **`Deref` Trait 的实现**: `MyBox` 和 `Box_` 都实现了 `Deref` trait,它们的核心实现逻辑完全相同.

  ```rust
  // 为 MyBox<T> 实现 Deref
  impl<T> Deref for MyBox<T> {
      type Target = T;
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  }

  // 为 Box_<T> 实现 Deref
  impl<T> Deref for Box_<T> {
      type Target = T;
      fn deref(&self) -> &Self::Target {
          &self.0
      }
  }
  ```

  这里的 `&self.0` 是返回元组结构体中第一个(也是唯一一个)成员的引用.

---

### 5. Deref 的实际应用

通过实现 `Deref`,我们可以对自定义的智能指针进行解引用,就像对原生引用一样.

- **解引用操作**:

  ```rust
  fn main() {
      // 创建一个 Box_ 实例,它包装了整数 2
      let x = Box_::new(2);

      // 直接使用 *x 进行解引用,会调用 Box_ 的 deref 方法,
      // 返回一个 &i32 引用,然后 * 再对这个引用进行解引用,得到整数 2
      assert_eq!(*x, 2);
  }
  ```

  这段代码能够成功运行,正是因为 `Box_<T>` 实现了 `Deref` trait,让 `*x` 的操作成为可能.

---

### 6. 指针的算术和 offset

你代码中的另一个重要部分是**原始指针**(`*mut i32`)的使用.

- **原始指针的创建**: `values.as_mut_ptr()` 会返回数组 `values` 第一个元素的原始指针.
- **指针算术**:
  - **手动计算**:你可以将原始指针转换为 `usize` 整数,然后手动加上 `std::mem::size_of::<i32>()` 的大小(对于 `i32` 来说是 4 个字节),再转回原始指针.这种方法容易出错.
  - **使用 `offset` 方法(更安全)**:`p1.offset(1)` 是更安全和惯用的方法.它会自动根据指针的类型(这里是 `*mut i32`)来计算偏移量,从而移动到下一个元素,无需手动计算字节大小.
- **`unsafe` 代码块**: 对原始指针进行解引用和操作(如 `*p2 += 1`)是**不安全**的操作,必须被包裹在 `unsafe` 代码块中.这是因为编译器无法保证指针的有效性,你需要自己确保它的指向是正确的.

---

## `Drop` Trait 核心概念

`Drop` trait 是 Rust 所有权系统的重要组成部分,它定义了当一个值离开作用域时应该执行的清理代码.

#### 1. 结构体字段的 `drop` 顺序

当你为一个包含其他实现了 `Drop` 的结构体的类型实现 `Drop` trait 时,Rust 的 `drop` 行为遵循以下规则:

1. 首先执行**父结构体**的 `drop` 方法.
2. 然后,按照字段在结构体中**声明的相反顺序**(从后往前),依次调用每个字段的 `drop` 方法.

```rust
struct HasDrop1;
struct HasDrop2;
impl Drop for HasDrop1 {
    fn drop(&mut self) {
        println!("Dropping HasDrop1!");
    }
}
impl Drop for HasDrop2 {
    fn drop(&mut self) {
        println!("Dropping HasDrop2!");
    }
}
struct HasTwoDrops {
    one: HasDrop1,
    two: HasDrop2,
}
impl Drop for HasTwoDrops {
    fn drop(&mut self) {
        println!("Dropping HasTwoDrops!");
    }
}

struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let _x = HasTwoDrops {
        two: HasDrop2,
        one: HasDrop1,
    };
    let _foo = Foo;
    println!("Running!");
}
```

```sh
Running!
Dropping Foo!
Dropping HasTwoDrops!
Dropping HasDrop2!
Dropping HasDrop1!
```

**顺序解释**: `main` 函数中,变量的 `drop` 顺序与它们的声明顺序相反.

1. `_foo` 首先被 drop,因此打印 `Dropping Foo!`.
2. `_x` 接着被 drop.
   - 首先执行 `HasTwoDrops` 自己的 `drop` 方法,打印 `Dropping HasTwoDrops!`.
   - 然后按照字段声明的相反顺序,先 drop `two` 字段,打印 `Dropping HasDrop2!`.
   - 最后 drop `one` 字段,打印 `Dropping HasDrop1!`.

如果你删除 `HasTwoDrops` 的 `impl Drop` 块,编译器会为它自动生成一个默认的 `drop` 方法,该方法只会按照字段的相反顺序调用其 `drop` 方法,因此输出将变为:

```sh
Running!
Dropping Foo!
Dropping HasDrop2!
Dropping HasDrop1!
```

---

#### 2. 手动调用 `drop`

你不能直接调用 `my_var.drop()`,因为这是编译器自动管理的方法.如果你想**提前销毁**一个值,应该使用标准库中的 `std::mem::drop` 函数.

**错误代码示例**:

```rust
#[derive(Debug)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let foo = Foo;
    // 编译错误:
    // `drop` 方法是编译器自动调用的,不能手动调用
    // foo.drop();
    println!("Running!:{:?}", foo);
}
```

**正确做法**:

```rust
use std::mem::drop;

#[derive(Debug)]
struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}

fn main() {
    let foo = Foo;
    // 使用 std::mem::drop 函数提前转移所有权并销毁
    drop(foo);

    // 这行会报错,因为 foo 的所有权已在上面被转移并销毁
    // println!("Running!:{:?}", foo);
}
```

---

#### 3. `Copy` Trait 与 `Drop` Trait 的互斥性

`Copy` 和 `Drop` 是互斥的.一个类型**不可能同时实现这两个 trait**.

- **`Copy`**:意味着当值被赋给新变量时,会进行**按位复制**,原始值和新值独立存在,所有权不转移.
- **`Drop`**:意味着当值的所有权结束时,需要执行**清理代码**.

如果一个类型同时实现这两个 trait,就会产生矛盾.例如,当一个 `Copy` 类型被复制后,两个独立的值都会在各自的作用域结束时被 `drop`,这可能导致资源被双重释放等严重问题.因此,Rust 编译器会强制阻止这种行为.

**错误代码示例**:

```rust
#[derive(Copy)]
struct Foo;

// 编译错误:
// `Foo` 类型不能同时实现 `Drop` 和 `Copy`
impl Drop for Foo {
    fn drop(&mut self) {
        println!("Dropping Foo!")
    }
}
```

---

## `Rc`和`Arc`

```rust
use std::rc::Rc;
fn main() {
    let x = Rc::new(String::from("sd"));
    let y = Rc::clone(&x);

    assert_eq!(2, Rc::strong_count(&x));
    assert_eq!(Rc::strong_count(&y), Rc::strong_count(&x));
}
```

使用 Rc::new 创建新的智能指针去赋值

```rust
use std::rc::Rc;
fn main() {
    let a = Rc::new(String::from("test ref counting"));
    println!("count = {}", Rc::strong_count(&a));
    let b = Rc::clone(&a);
    println!("count = {}", Rc::strong_count(&a));
    {
        let c = Rc::clone(&a);
        println!("count = {}", Rc::strong_count(&c));
    }
    println!("count after scope = {}", Rc::strong_count(&a));
}
```

```rust
use std::rc::Rc;

struct Owner {
    name: String,
}

struct Gadget {
    id: i32,
    owner: Rc<Owner>,
}

fn main() {
    let gadget_owner: Rc<Owner> = Rc::new(Owner {
        name: "Gadget Man".to_string(),
    });

    // 初始引用计数为 1
    println!("初始引用计数: {}", Rc::strong_count(&gadget_owner));

    let gadget1 = Gadget {
        id: 1,
        owner: Rc::clone(&gadget_owner),
    };
    let gadget2 = Gadget {
        id: 2,
        owner: Rc::clone(&gadget_owner),
    };

    // 创建两个新引用后,引用计数为 3
    println!(
        "创建两个 Gadget 后,引用计数: {}",
        Rc::strong_count(&gadget_owner)
    );

    // 释放掉第一个 `Rc<Owner>`
    drop(gadget_owner);
    // 尽管在上面我们释放了 gadget_owner,但是依然可以在这里使用 owner 的信息
    // 原因是在 drop 之前,存在三个指向 Gadget Man 的智能指针引用,上面仅仅
    // drop 掉其中一个智能指针引用,而不是 drop 掉 owner 数据,外面还有两个
    // 引用指向底层的 owner 数据,引用计数尚未清零
    // 因此 owner 数据依然可以被使用

    // 释放一个引用后,引用计数为 2
    // 这里的 `gadget1.owner` 仍然持有对 Owner 数据的引用
    println!(
        "drop(gadget_owner) 后,引用计数: {}",
        Rc::strong_count(&gadget1.owner)
    );

    println!("Gadget {} owned by {}", gadget1.id, gadget1.owner.name);
    println!("Gadget {} owned by {}", gadget2.id, gadget2.owner.name);
    // 在函数最后,`gadget1` 和 `gadget2` 也被释放,最终引用计数归零,随后底层
    // 数据也被清理释放
}
```

```rust
use std::rc::Rc;
use std::sync::Arc;
use std::thread;

fn main() {
    // let s = Rc::new(String::from("多线程漫游者"));
    // for _ in 0..10 {
    //     let s = Rc::clone(&s);
    //     let handle = thread::spawn(move || println!("{}", s));
    // }

    let s = Arc::new(String::from("多线程漫游者"));
    for _ in 0..10 {
        let s = Arc::clone(&s);
        let handle = thread::spawn(move || println!("{}", s));
    }
}
```

## `Cell`和`Refcell`

### `Cell<T>`

`Cell<T>` 适用于实现了 `Copy` trait 的类型(比如所有基本数字类型,`bool`,`char` 等,但是对于哪些没有实现的类型 比如`String`和自定义的结构,是不可以的).它的核心思想是**复制**.当你想要修改值时,它会取出旧值的副本,用新值替换.

**`Cell` 的理想应用场景是:**

1. 你需要在不可变上下文中修改数据.
2. 被修改的数据是**小而简单**的,实现了 `Copy` 特性.
3. 你不希望有借用检查的开销(`Cell` 是零开销的,而 `RefCell` 有运行时开销).

#### 主要方法:

- `Cell::new(value: T)`: 创建一个新的 `Cell`.
- `cell.get() -> T`: 获取 `Cell` 内部值的副本.
- `cell.set(value: T)`: 用新值替换 `Cell` 内部的值.
- `cell.into_inner() -> T`: 销毁 `Cell`,并返回其内部的值.

```rust
use std::cell::Cell;

fn main() {
    let my_number = Cell::new(10); // 创建一个 Cell

    // 我们有一个不可变引用,但依然可以修改它内部的值
    let my_number_ref = &my_number;

    // 获取内部值的副本
    let current_value = my_number_ref.get();
    println!("当前值: {}", current_value);

    // 设置一个新值
    my_number_ref.set(20);
    println!("新值: {}", my_number.get());

    // into_inner() 将销毁 Cell 并返回最终值
    let final_value = my_number.into_inner();
    println!("最终值: {}", final_value);
}
```

---

### `RefCell<T>`

`RefCell<T>` 适用于**任何类型**,它提供了**运行时借用检查**.这意味着它允许你在运行时借用一个可变引用,但会检查是否违反了借用规则(比如试图同时创建两个可变借用 或者 不可变和可变借用同时存在),而且和正常的一样,如果想要使用`.borrow_mut()`的前提是定义的是一个`mut`类型的变量.  
如果违反了规则,程序会 `panic`.

```rust
use std::cell::RefCell;

fn main() {
    let my_data = RefCell::new(vec![1, 2, 3]);

    println!("初始数据: {:?}", my_data.borrow());

    // 获取一个可变借用,可以修改数据
    {
        let mut mut_borrow = my_data.borrow_mut();
        mut_borrow.push(4);
    } // mut_borrow 在这里超出作用域并被释放

    println!("修改后数据: {:?}", my_data.borrow());

    //    尝试同时创建多个可变借用会 panic
    // {
    //     let mut mut_borrow1 = my_data.borrow_mut();
    //     let mut mut_borrow2 = my_data.borrow_mut(); // 运行时 panic
    // }

    // 尝试在可变借用 &mut T 存在 创建不可变借用 &T 也会 panic
    // 而且下面这样 是 同时存在 & T 和&mut T 的
    // {
    //     let borrow = my_data.borrow(); // 运行时 panic
    //     println!("borrow = {:?}", borrow);
    //     let mut_borrow = my_data.borrow_mut();
    // }

    // 获取并且销毁Refcell的数据
    println!("{:?}", my_data.into_inner());
}
```

### 简单版总结

| 智能指针      | 核心作用                                                                                  |
| ------------- | ----------------------------------------------------------------------------------------- |
| **`Box<T>`**  | 负责在堆上存储数据,实现对数据的**唯一所有权**.                                            |
| **`Rc<T>`**   | 可以实现一个数据拥有**多个所有者**,它通过引用计数确保在**单线程**中共享数据.              |
| **`Arc<T>`**  | 实现一个数据拥有**多个所有者**,用于在**多线程**中安全地共享数据.                          |
| **`Weak<T>`** | 提供了对数据的**非所有权引用**,它与 `Rc` 或 `Arc` 配合使用,用来打破循环引用,防止内存泄漏. |
| `Cell<T>`     | 允许在不可变引用的情况下,对 `Copy` 类型的数据进行修改,非`Copy`类型需要使用`RefCell`.      |
| `RefCell<T>`  | 允许在不可变引用的情况下,对**所有类型**的数据进行修改,通过运行时检查确保安全.             |

### Rust 智能指针功能总结

| 智能指针      | 核心功能     | 核心作用                                                                      |
| ------------- | ------------ | ----------------------------------------------------------------------------- |
| **`Box<T>`**  | 唯一所有权   | 将数据存储在**堆上**,当数据在栈上过大或需要递归类型时使用.                    |
| **`Rc<T>`**   | 多所有权     | 实现一个数据拥有**多个所有者**,用于在**单线程**中共享数据.                    |
| **`Arc<T>`**  | 多所有权     | 实现一个数据拥有**多个所有者**,用于在**多线程**中安全地共享数据.              |
| **`Weak<T>`** | 非所有权引用 | 打破循环引用,配合 `Rc` 或 `Arc` 使用,防止内存泄漏.                            |
| `Cell<T>`     | 内部可变性   | 允许在不可变引用的情况下,对 `Copy` 类型的数据进行修改.                        |
| `RefCell<T>`  | 内部可变性   | 允许在不可变引用的情况下,对**所有类型**的数据进行修改,通过运行时检查确保安全. |

---

### 保留 Vec 中偶数元素的几种方法

#### 错误示例

```rust
fn is_even(i: i32) -> bool {
    i % 2 == 0
}
fn retain_even_0(nums: &mut Vec<i32>) {
    let mut i = 0;
    for num in nums.iter_mut().filter(|num| is_even(**num)) {
        nums[i] = *num;
        i += 1;
    }
    nums.truncate(i);
}
```

错误的地方:违反了 Rust 的**借用规则**,即在同一时间对同一数据持有两个可变借用:

1. `nums.iter_mut()`:调用 `iter_mut()` 时,Rust 提供一个**可变迭代器**.这个迭代器在整个 `for` 循环期间会持有对 `nums` 向量的一个**可变借用**.这意味着在循环执行时不能以任何其他方式修改 `nums`.
2. `nums[i] = *num;`:在循环内部,试图通过索引 `nums[i]` 来修改向量.这种操作本质上是又一次对`nums`的**可变借用** .

由于一个变量不能同时被两个可变引用借用,这种写法是无效的.

### 三种可行的解决方案

#### 1. 传统的手动实现(`retain_0`)

这种方法通过使用两个索引来避免借用冲突,一个用于读取,一个用于写入.

```rust
fn retain_0(nums: &mut Vec<i32>) {
    let mut i = 0;
    for j in 0..nums.len() {
        if is_even(nums[j]) {
            nums[i] = nums[j];
            i += 1;
        }
    }
    nums.truncate(i);
}
```

#### 2.使用标准库函数(`retain_1`)

这是最推荐和最符合 Rust 习惯的做法.`Vec::retain()` 函数专门用于原地过滤向量.

```rust
fn retain_1(nums: &mut Vec<i32>) {
    nums.retain(|&num| is_even(num));
}
```

#### 3. 使用 `Cell` 内部可变性(`retain_2`)

这种方法展示了如何利用 Rust 的**内部可变性**(Interior Mutability)来绕过借用检查器.

```rust
use std::cell::Cell;

fn retain_2(nums: &mut Vec<i32>) {
    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..]).as_slice_of_cells();
    let mut count = 0;
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[count].set(num.get());
        count += 1;
    }
    nums.truncate(count);
}
```

#### 对其中的 Cell 方法 的讲解

这个方案依赖于 `Cell` 类型,它允许你在拥有不可变引用的同时修改数据.

- **`Cell::from_mut(&mut nums[..])`**:
  - `&mut nums[..]` 获取 `nums` 向量的**可变切片**.
  - `Cell::from_mut(...)` 将这个可变引用 `&mut [i32]` 转换为一个 `&Cell<[i32]>`.这相当于把**整个切片封装进一个 `Cell` 中**,从而提供了内部可变性.
- **`&Cell<[i32]>` 和 `&[Cell<i32>]` 的区别**:
  - **`&Cell<[i32]>`**: 整个切片被当作一个单一的 `Cell` 对象.你有一个不可变引用指向这个 `Cell`,但无法直接访问内部元素的可变性.
  - **`&[Cell<i32>]`**: 这是由 `Cell<i32>` 组成的切片.切片本身是不可变的,但**每个元素**都是一个独立的 `Cell`,可以通过其 `set()` 方法修改内部值.
- **`.as_slice_of_cells()`**:
  - 这个方法将 `&Cell<[i32]>` **转换**为 `&[Cell<i32>]`.
  - 这一步是关键,它把可变性从“整个切片”转移到了“切片中的每个元素”,这样我们就可以在遍历切片的同时修改其内部的元素.
- **`for ...` 循环中的操作**:
  - `slice.iter()`: 得到一个**不可变**迭代器,符合借用规则.
  - `num.get()`: 因为 `num` 是一个 `&Cell<i32>`,`get()` 方法会获取内部值的**副本**,用于判断是否为偶数.
  - `slice[count].set(...)`: 通过索引访问切片中的 `Cell`,然后使用 `set()` 方法**安全地修改其内部值**.
- **`nums.truncate(count)`**:
  - 在循环结束后,向量中偶数元素被移动到了前面,`count` 记录了偶数的数量.
  - `truncate()` 方法会根据 `count` 的值截断向量,移除多余的元素.

#### 总体的代码

```rust
use std::cell::Cell;

fn main() {
    let mut x = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    retain_0(&mut x);
    retain_1(&mut x);
    retain_2(&mut x);
    println!("{:?}", x);
    assert_eq!(x, vec![2, 4, 6, 8, 10]);
}
fn is_even(i: i32) -> bool {
    i % 2 == 0
}
fn retain_0(nums: &mut Vec<i32>) {
    let mut i = 0;
    for j in 0..nums.len() {
        if is_even(nums[j]) {
            nums[i] = nums[j];
            i += 1;
        }
    }
    nums.truncate(i);
}

fn retain_1(nums: &mut Vec<i32>) {
    //调用库函数 `.retain()` 用于原地过滤向量
    nums.retain(|&num| is_even(num));
}

fn retain_2(nums: &mut Vec<i32>) {
    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..]).as_slice_of_cells();
    let mut count = 0;
    //对新得到的 &[Cell<i32>]类型的切片 slice进行处理
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[count].set(num.get());
        count += 1;
    }
    nums.truncate(count);
}
```

## 常见智能指针的组合
