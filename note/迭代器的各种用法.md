给出一个值求阶乘

```rust
fn factorial(num: u64) -> u64 {
    (1..=num).product()
}
```

为什么能这样? `(1..=num)`创造了一个从 1 到 num 范围的迭代器,于是可以调用他的属性

`product`

哈希表的迭代方式不是 `into` 而是

### Rust 迭代器:`IntoIterator` 与 `Iterator`

在 Rust 中,`IntoIterator` 和 `Iterator` 是迭代器系统的核心.它们的角色和关系可以这样理解:

- **`IntoIterator`** 是**“工厂”**和“”**处理器**“”,它定义了如何将一个**集合(Collection)**转换为一个迭代器.
- **`Iterator`** 是**“迭代器”**本身,它定义了如何从集合中**逐个取值**.

`for` 循环是连接这两个概念的桥梁.当 Rust 编译器看到 `for item in collection` 时,它会做两件事:

1. 调用 `collection` 的 `IntoIterator` 特征方法,将其转换为一个迭代器.
2. 在生成的迭代器上反复调用 `next()` 方法,直到返回 `None`.

考虑以下等价的代码,也就是说`IntoIterator `这个`trait`是把一个`collection` 转换为一个迭代器,而这个迭代器的类型是`Iterarot`

```rust
fn main() {
    let v = vec![1, 2, 3];

    // 实际上,编译器会把 `for item in v` 转换成类似下面的代码:
    let mut iterator = IntoIterator::into_iter(v);
    while let Some(item) = iterator.next() {
        println!("{}", item);
    }

    //以上发生了所有权的转移 消耗了v 因此下面会出错
    // for item in v {
    //     println!("{}", item);
    // }
}
```

---

### 对比表格

| 方法/特征          | 核心作用           | `self` 参数类型        | 原始对象的所有权  | 迭代的元素类型   |
| ------------------ | ------------------ | ---------------------- | ----------------- | ---------------- |
| **`IntoIterator`** | 将集合转换为迭代器 | `self` (值)            | **被消耗**(Moved) | `T` (元素所有权) |
| **`Iterator`**     | 驱动迭代过程       | `&mut self` (可变引用) | 无关              | `Item`           |

---

### `Vec` 的三种迭代方式

`Vec<T>` 提供了三种不同的迭代器,以适应不同的需求.这些方法都是 `IntoIterator` 特征的不同实现:

#### 1. `iter()`: 不可变借用

当你在一个不可变引用 `&Vec<T>` 上调用 `into_iter()` 时,它会返回一个迭代器.`Vec` 上的 `iter()` 方法其实就是这个特性的语法糖.

- **方法签名**:`fn iter(&self) -> Iter<'_, T>`
- **所有权**:**不会**消耗原始 `Vec`.
- **元素类型**:产生**不可变引用 `&T`**.
- **用途**:只读迭代.

```rust
let v = vec![1, 2, 3];
for item in v.iter() {
    println!("不可变引用: {}", item); // item 的类型是 &i32
}
println!("迭代后 v 仍然可用:{:?}", v);
```

#### 2. `iter_mut()`: 可变借用

当你在一个可变引用 `&mut Vec<T>` 上调用 `into_iter()` 时,它会返回一个迭代器.`Vec` 上的 `iter_mut()` 方法就是这个特性的语法糖.

- **方法签名**:`fn iter_mut(&mut self) -> IterMut<'_, T>`
- **所有权**:**不会**消耗原始 `Vec`.
- **元素类型**:产生**可变引用 `&mut T`**.
- **用途**:迭代时修改元素.

```rust
let mut v = vec![1, 2, 3];
for item in v.iter_mut() {
    *item *= 2; // 可以修改元素
}
println!("迭代后 v 仍然可用且被修改:{:?}", v); // 输出: [2, 4, 6]
```

#### 3. `into_iter()`: 消耗所有权

当你在一个值 `Vec<T>` 上调用 `into_iter()` 时,它会返回一个迭代器.`for` 循环就是默认使用这种方式.

- **方法签名**:`fn into_iter(self) -> IntoIter<T>`
- **所有权**:**会**消耗原始 `Vec`.
- **元素类型**:产生**值 `T`**.
- **用途**:获取元素所有权,且迭代后不再使用原始集合.

```rust
let v = vec![1, 2, 3];
let mut sum = 0;
for item in v.into_iter() {
    sum += item; // item 的类型是 i32
}
// println!("v 仍然可用:{:?}", v); // 这行代码会引发编译错误！
```

`for` 循环的本质是调用 `into_iter()`.所有权转移由调用方式决定:

- `for item in collection` → 隐式调用 `collection.into_iter()` → **消耗所有权**.
- `for item in &collection` → 隐式调用 `(&collection).into_iter()` → **不可变借用**.
- `for item in &mut collection` → 隐式调用 `(&mut collection).into_iter()` → **可变借用**.

也就是默认的方法

`for item in collection` 是 使用了`collection.into_iter()`会消耗所有权

因此,如果你需要在 `for` 循环后继续使用集合,必须显式地使用 `&v` 或 `&mut v`.

---

## Rust 关联类型:`type Item`

**关联类型**(Associated Types)是 Rust 中用于 `trait` 的一个强大功能.它允许你在 `trait` 定义中声明一个**类型占位符**,其具体类型由 `trait` 的**实现者**来指定.

简单来说,关联类型将类型绑定到 `trait` 本身,而不是 `trait` 的泛型参数.

#### 为什么使用它?

使用关联类型的主要原因是**提高代码清晰度**和**避免歧义**.它适用于那些类型应该与 `trait` 实现一一对应的场景.

例如,一个迭代器不可能同时产生 `i32` 和 `String`,它的元素类型是**唯一确定**的.如果使用泛型,你需要为每个可能的类型都写一个实现,这既冗长又容易出错.关联类型通过强制实现者在 `impl` 块中唯一指定类型,解决了这个问题.

---

### 1. `Iterator` 特征中的 `type Item`

这是关联类型最经典的用法.`Iterator` 特征定义了一个 `next()` 方法,它需要知道每次迭代返回的元素类型.`type Item` 正是为了这个目的而生.

```rust
// Trait 定义
trait Iterator {
    // 声明一个关联类型 Item
    type Item;

    // next 方法返回 Option<元素类型>
    fn next(&mut self) -> Option<Self::Item>;
}

// Vec<i32> 的迭代器实现
impl Iterator for std::slice::Iter<'_, i32> {
    // 为这个迭代器指定 Item 的具体类型为 i32
    type Item = &'static i32;

    fn next(&mut self) -> Option<Self::Item> {
        // ... 具体实现 ...
        unimplemented!()
    }
}
```

在这个例子中:

- `type Item;` 声明了 `Item` 占位符.
- `impl` 块中的 `type Item = &'static i32;` 将 `Item` 具体指定为 `&'static i32`.
- `Self::Item` 在方法签名中引用了这个具体的类型.

---

### 2. 自定义容器的例子

假设我们要创建一个通用的 `Container` `trait`,它能返回其中的一个元素.使用关联类型可以确保每个容器类型都有一个唯一的元素类型.

```rust
// 定义一个 Container trait
trait Container {
    // 声明关联类型
    type Item;

    fn get_item(&self) -> Self::Item;
}

// 容器 1: 存储 i32
struct IntContainer {
    value: i32,
}

// 为 IntContainer 实现 Container
impl Container for IntContainer {
    // 指定 Item 为 i32
    type Item = i32;

    fn get_item(&self) -> Self::Item {
        self.value
    }
}

// 容器 2: 存储 String
struct StringContainer {
    value: String,
}

// 为 StringContainer 实现 Container
impl Container for StringContainer {
    // 指定 Item 为 String
    type Item = String;

    fn get_item(&self) -> Self::Item {
        self.value.clone()
    }
}

fn main() {
    let int_cont = IntContainer { value: 42 };
    let string_cont = StringContainer { value: "Rust".to_string() };

    // 编译器会自动推断 get_item() 的返回类型
    let int_item = int_cont.get_item();     // 类型是 i32
    let string_item = string_cont.get_item(); // 类型是 String

    println!("Int item: {}", int_item);
    println!("String item: {}", string_item);
}
```

通过使用关联类型,我们定义了一个通用的 `Container` `trait`,但每个实现者都能够绑定自己的特定类型,从而避免了泛型可能带来的类型不确定性.

### 手动实现迭代器`trait`的例子

```rust
struct Counter {
    count: u32,
}
impl Counter {
    fn new() -> Self {
        Self { count: 0 }
    }
}
impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 10 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
fn main() {
    let mut ct = Counter::new();
    assert_eq!(ct.next(), Some(1));
    assert_eq!(ct.next(), Some(2));
    assert_eq!(ct.next(), Some(3));
    assert_eq!(ct.next(), Some(4));
}
```

另一个例子

```rust
// Step 1: 定义 Book 结构体
struct Book {
    title: String,
    pages: Vec<String>,
}

// ----------------------------------------------------
// Step 2: 定义迭代器结构体
// ----------------------------------------------------
struct BookIterator<'a> {
    book: &'a Book,
    current_page: usize,
}

// ----------------------------------------------------
// Step 3: 为迭代器实现 Iterator trait
// ----------------------------------------------------
impl<'a> Iterator for BookIterator<'a> {
    // 关联类型 Item 指定迭代器返回的元素类型
    type Item = &'a str;

    fn next(&mut self) -> Option<Self::Item> {
        // 如果当前页索引小于总页数
        if self.current_page < self.book.pages.len() {
            // 获取当前页的引用
            let page_content = &self.book.pages[self.current_page];
            // 索引前进一页
            self.current_page += 1;
            // 返回当前页的引用
            Some(page_content)
        } else {
            // 所有页都已读完,返回 None
            None
        }
    }
}

// ----------------------------------------------------
// Step 4: 为 Book 实现 IntoIterator trait
// ----------------------------------------------------
impl<'a> IntoIterator for &'a Book {
    type Item = &'a str;
    type IntoIter = BookIterator<'a>;

    fn into_iter(self) -> Self::IntoIter {
        // 创建一个新的 BookIterator 实例
        BookIterator {
            book: self,
            current_page: 0,
        }
    }
}

fn main() {
    let my_book = Book {
        title: "Rust 编程指南".to_string(),
        pages: vec![
            "第一页: 欢迎来到 Rust！".to_string(),
            "第二页: 深入理解所有权.".to_string(),
            "第三页: 掌握迭代器.".to_string(),
        ],
    };

    println!("--- 正在阅读 '{}' ---", my_book.title);

    // 使用 for 循环遍历 my_book
    // 编译器会自动调用 (&my_book).into_iter()
    for page in &my_book {
        println!("{}", page);
    }

    // 循环结束后,my_book 仍然可用
    println!("----------------------------------");
    println!("全书共有 {} 页.", my_book.pages.len());
}
```

---

### **消费器(Consumer)**和**适配器(Adapter)**

- **适配器**是**惰性的**,它接收一个迭代器,并返回另一个**新的迭代器**.它不消耗数据,只是准备好下一步的计算.
- **消费器**是**急切的**,它接收一个迭代器,并**消耗**它并且转义走消费其的所有权以产生一个最终结果.它会触发整个迭代过程的执行.

---

### 1. 适配器(Adapters)

适配器方法是链式调用的核心.它们接收一个迭代器,并返回一个**新的迭代器**,让你可以继续调用其他适配器或消费器.适配器本身不做任何实际计算,直到消费器被调用.

**举例**:

假设我们有一个数字向量 `v`,我们想先过滤掉奇数,然后将每个偶数乘以 2.

```rust
let v = vec![1, 2, 3, 4, 5, 6];

// filter() 和 map() 都是适配器
let adapter = v.iter()
               .filter(|&x| x % 2 == 0) // 筛选出偶数
               .map(|x| x * 2);      // 将每个偶数乘以 2

// 在这之前,没有任何计算发生.
// `adapter` 只是一个“指令链”,描述了如何处理数据.
```

在这个例子中,`.filter()` 和 `.map()` 都返回一个新的迭代器.它们是惰性求值的,`v.iter()` 在被 `filter` 和 `map` 适配器调用时,还没有产生任何实际的数字.

---

### 2. 消费器(Consumers)

消费器方法是迭代器链的**终点**.当一个消费器被调用时,它会触发整个链式调用中的所有适配器,并**消耗**迭代器中的所有元素,返回一个最终结果.

**举例**:

现在我们使用不同的消费器来完成上面的例子.

- **`.collect()`**:这是一个常见的消费器,它将迭代器中的所有元素收集到一个集合中.

  ```rust
  let v = vec![1, 2, 3, 4, 5, 6];

  let result_vec: Vec<i32> = v.iter()
                              .filter(|&x| x % 2 == 0)
                              .map(|x| x * 2)
                              .collect(); // <--- 消费器,触发计算

  println!("{:?}", result_vec); // 输出: [4, 8, 12]
  ```

  `collect()` 一旦被调用,`filter` 和 `map` 中的计算就会立即执行,并将最终结果收集到 `result_vec` 中.

- **`.sum()`**:这个消费器会计算所有元素的总和.

  ```rust
  let v = vec![1, 2, 3, 4, 5, 6];

  let result_sum: i32 = v.iter()
                         .filter(|&x| x % 2 == 0)
                         .map(|x| x * 2)
                         .sum(); // <--- 消费器,触发计算

  println!("{}", result_sum); // 输出: 24 (4 + 8 + 12)
  ```

  与 `collect()` 类似,`sum()` 也消耗了迭代器,并返回一个单一的值.

- **`cloned()`**:对迭代器的元素使用`clone()`方法进行复制

  ```rust
  let v1 = vec![1, 2, 3];
  // v1.iter() 返回一个 &i32 的迭代器
  // .cloned() 对每个 &i32 调用 .clone()，返回一个 i32 的迭代器
  let v2: Vec<i32> = v1.iter().cloned().collect();
  println!("{:?}", v2); // 输出: [1, 2, 3]
  ```

  这比使用 `map` 闭包来手动解引用更简洁：

  ```rust
  // 效果相同，但 cloned() 表达意图更清晰
  let v3: Vec<i32> = v1.iter().map(|&x| x).collect();
  ```

### 总结

- **适配器**(如 `map`, `filter`, `zip`):**转换**迭代器,返回新的迭代器.
- **消费器**(如 `collect`, `sum`, `count`, `fold`):**消耗**迭代器,返回最终结果.

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];

    // filter() 和 map() 都是适配器
    let adapter = v
        .iter()
        .filter(|&x| x % 2 == 0) // 筛选出偶数
        .map(|x| x * 2) // 将每个偶数乘以 2
        ;
    println!("adapter: {:#?}", adapter);
    // 在这之前,没有任何计算发生. 使用消费器后 适配器的onwership被转移 ,并且需要手动指定新的类型
    let container: Vec<_> = adapter.collect();
    //println!("adapter: {:#?}", adapter); // 已经被转移,无法使用
}
```
