### 孤儿规则

**当您为一个类型实现一个 Trait 时,这个 Trait 或这个类型,至少有一个必须是您在当前 crate(项目)中定义的.**

换句话说,您不能在您的 `crate A` 中,为一个从 `crate B` 引入的类型 `TypeB` 实现一个从 `crate C` 引入的 Trait `TraitC`.

## Rust 官方的说法:**“一个 `impl` 块必须至少属于当前 crate 中的一个 Trait 或一个 Type.”**

```rust
// 您的 crate
// 假设 `serde::Serialize` 是外部 Trait
// 假设 `std::vec::Vec` 是外部类型

// impl Serialize for Vec<i32> { // ❌ 不允许:Trait 和 Type 都不是您的！
//     // ... 实现细节
// }
```

### 孤儿规则核心

用最简洁的话来说,Rust 的**孤儿规则(Orphan Rule)**就是要求:

对于一个 `impl TraitName for TypeName` 这样的实现块,`TraitName` 和 `TypeName` **至少有一个**必须是您在当前 `crate` (也就是您正在编写的 Rust 项目或库) 中定义的.

---

### 规则图示

| 情况        | TraitName 是当前 Crate 定义的? | TypeName 是当前 Crate 定义的? | 是否允许?  | 示例说明                                                                                               |
| ----------- | ------------------------------ | ----------------------------- | ---------- | ------------------------------------------------------------------------------------------------------ |
| **情况一:** | ✅ 是                          | ✅ 是                         | **允许**   | 您为自己定义的结构体实现自己定义的 trait.                                                              |
| **情况二:** | ✅ 是                          | ❌ 否                         | **允许**   | 您为标准库或第三方库的类型(如 `Vec<T>`、`String`)实现您自己定义的 trait.这非常常见.                    |
| **情况三:** | ❌ 否                          | ✅ 是                         | **允许**   | 您为自己定义的结构体实现标准库或第三方库的 trait(如 `serde::Serialize`、`std::fmt::Debug`).这也很常见. |
| **情况四:** | ❌ 否                          | ❌ 否                         | **不允许** | 您不能为标准库或第三方库的类型实现标准库或第三方库的 trait.这是**孤儿规则**主要阻止的行为.             |

匯出到試算表

---

### 为什么这样设计?

这个规则的主要目的是为了**避免不同库之间的 Trait 实现冲突**.如果允许情况四,那么当多个独立开发的库都尝试为同一个“外部”类型实现同一个“外部” Trait 时,就会出现歧义和不确定性,导致项目无法编译或行为异常.

孤儿规则确保了每个 `impl` 块都有一个明确的“归属地”,从而保证了整个 Rust 生态系统的**一致性和稳定性**.

## 基本泛型语法规则

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    // 实现 mixup,不要修改其它代码！
    fn mixup(&self, other: Point<T, U>) -> Self {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: "Hello", y: '中' };

    let p3 = p1.mixup(p2);

    assert_eq!(p3.x, 5);
    assert_eq!(p3.y, '中');
}
```

泛型特例化

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5 as f32, y: 10 as f32};
    println!("{}",p.distance_from_origin())
}
```

## const 泛型

这里没学会...

```rust
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}
```

## 结合 trait 的泛型

一般特征写法

```rust
pub trait TraitName_1 {
    fn func1(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {
        // 函数体的默认实现 或者为空
    }
    fn func2(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {}
}

pub trait TraitName_2 {
    fn func3(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {
        // 函数体的默认实现 或者为空
    }
    fn func4(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {}
}

//对不同的类型实现 Trait
impl TraitName_1 for TypeName1 {
    fn func1(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {
        // 函数体的实现
    }
    // func2 可以使用 Trait 的默认实现
}
impl TraitName_2 for String {
    fn func3(&self, arg1: Type1, arg2: Type2) -> 具体类型Type {
        // 函数体的实现
    }
    // func4 可以使用 Trait 的默认实现
}
```

## 使用 trait 作为函数参数

这里的 item 的类型是 任何实现了 `Summary`这个`trait` 的类型

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

//完整形式如下
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

继续看例子
第一种写法的问题是可能`item1 item2`的类型不相同,也就是可能一个是`i32` 一个是`f64`

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}

//保证了是同一种类型
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

参数的多重`trait`约束 展开为下面的

```rust
fn function<T: Trait1 + Trait2, U: Trait3 + Trait4 + Trait5>(x: &T, y: &U) -> i32 {}
fn function<T, U>(x: &T, y: &U) -> i32
where
    T: Trait1 + Trait2,
    U: Trait3 + Trait4 + Trait5,
{
    //...
}
```

## 函数的返回类型可以是`impl TraitName`

用于声名实现了某个`trait`的类型
但是这种返回值方式有一个很大的限制:只能有一个具体的类型,下面就不行,因为有两种返回值`Post`和`Weibo`

```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
            title: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Weibo {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
        }
    }
}
```

## 对泛型实现各种功能

```rust
fn add<T: std::ops::Add<Output = T>>(a:T, b:T) -> T {
    a + b
}
```
