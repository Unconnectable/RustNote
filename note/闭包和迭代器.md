# Rust 闭包(Closure)

## 基础闭包知识

闭包是一种可以捕获其周围环境(即外部作用域)变量的匿名函数.Rust 的闭包主要有三种类型,对应三种不同的 `Fn` Trait.

### 1. `Fn` Trait 的关系

一个闭包会根据其对捕获变量的使用方式,自动实现以下 `Fn` Trait 中的一个或多个:

- `FnOnce`:所有的闭包都至少实现了 `FnOnce`.它表示闭包**可以被调用一次**.如果闭包需要消耗捕获变量的所有权,它将只实现 `FnOnce`.
- `FnMut`:如果闭包需要**可变地借用**捕获变量,则它会自动实现 `FnMut`.这类闭包可以被多次可变调用.
- `Fn`:如果闭包只**不可变地借用**捕获变量,则它会自动实现 `Fn`.这类闭包可以被多次不可变调用.

**关系总结**:`Fn` 是 `FnMut` 的子集,`FnMut` 是 `FnOnce` 的子集.这意味着实现了 `Fn` 的闭包也自动实现了 `FnMut` 和 `FnOnce`.

### 2. `move` 关键字的核心作用

`move` 关键字的作用是改变闭包捕获外部变量的方式.

- **默认捕获(不使用 `move`)**:
  - 编译器会根据闭包对变量的操作,自动选择最不严格的捕获方式.
  - 如果只**读取**变量,闭包会通过**不可变引用** (`&`) 捕获,并实现 `Fn` Trait.
  - 如果需要**修改**变量,闭包会通过**可变引用** (`&mut`) 捕获,并实现 `FnMut` Trait.
- **使用 `move` 关键字**:
  - `move` 强制闭包**以值**(by value)的方式捕获所有外部变量.
  - 这意味着闭包会**获取这些变量的所有权**.
  - 一旦闭包被创建,被 `move` 捕获的变量在外部作用域中将**立即失效**.
  - 因为闭包拥有了变量的所有权,它自动实现了 `FnOnce` Trait.

---

### 3. 代码示例

#### 示例 1:强制实现 `FnOnce` Trait

这个例子展示了如何使用 `move` 关键字,将 `my_vec` 的所有权转移给闭包,从而强制闭包实现 `FnOnce` Trait.

```rust
fn call_once<F: FnOnce()>(f: F) {
    f();
}

fn main() {
    let my_vec = vec![1, 2, 3];

    // 使用 move 关键字,将 my_vec 的所有权转移给闭包
    let my_closure = move || {
        // 闭包拥有了 my_vec,并在这里使用它
        println!("闭包执行,向量的长度是: {}", my_vec.len());
    };

    // my_closure 实现了 FnOnce,因为当它被传入 call_once 函数时,闭包本身的所有权被消耗了
    call_once(my_closure);

    // 编译失败:my_vec 的所有权已被转移
    // println!("{:?}", my_vec);

    // 编译失败:my_closure 的所有权已被 call_once 函数消耗
    // call_once(my_closure);
}
```

**解析**:

1. **所有权转移到闭包**:`let my_closure = move || { ... };` 语句将 `my_vec` 的所有权转移到 `my_closure` 闭包中.
2. **闭包所有权转移到函数**:`call_once(my_closure);` 语句将 `my_closure` 的所有权转移到 `call_once` 函数.
3. **闭包被消耗**:`call_once` 函数调用闭包 `f()` 后,闭包及其拥有的 `my_vec` 会在函数结束时被销毁,因此闭包只能被调用一次.

---

#### 示例 2:闭包捕获所有权但可多次调用

这个例子展示了 `move` 关键字是如何将所有权转移给闭包,但闭包本身并不会消耗这个所有权,因此可以被多次调用.

```rust
fn main() {
    let movable = Box::new(3);

    // 使用 move 将 movable 的所有权转移给闭包
    let consume = move || {
        println!("`movable`: {:?}", movable);
    };

    // 因为闭包内部只是不可变地借用 movable(用于 println!),
    // 闭包没有消耗 movable 的所有权,因此可以多次调用
    consume();
    consume();

    // 编译失败:movable 的所有权已转移
    // println!("{:?}", movable);
}
```

**解析**:

- **`move` 强制捕获所有权**:`let consume = move || { ... };` 语句将 `movable` 的所有权转移到 `consume` 闭包中.
- **闭包内部操作**:虽然 `consume` 闭包拥有 `movable` 的所有权,但 `println!` 宏在内部只是对 `movable` 进行了**不可变借用**.
- **所有权未被消耗**:因为闭包内部没有转移或消耗 `movable` 的所有权,所以 `consume` 闭包本身的所有权也没有被消耗,它实现了 `Fn` Trait,可以被安全地多次调用.

**注意**:如果你在闭包内调用 `take(movable)`(`take` 函数会消耗传入的值),闭包就不能被多次调用了.这正是 `FnOnce` 的核心思想.

---

### 4. 总结:`move` 关键字的差异

| 特性         | **有 `move` 关键字**                                     | **没有 `move` 关键字**                       |
| ------------ | -------------------------------------------------------- | -------------------------------------------- |
| **捕获方式** | 强制**移动**所有权.                                     | 根据使用方式**借用**所有权.                 |
| **闭包类型** | 自动实现 `FnOnce` Trait.                                | 自动实现 `Fn` 或 `FnMut` Trait.             |
| **外部变量** | 闭包创建后,外部变量**立即失效**.                       | 外部变量所有权**保留**,闭包只持有引用.     |
| **多次调用** | 除非不消耗捕获的变量,否则**无法**多次调用.             | **可以**多次调用.                           |
| **主要用途** | 在多线程环境中安全地传递所有权,或将所有权转移到闭包中. | 在不转移所有权的情况下,访问和修改外部变量. |

---

## 闭包参数相关

### 1. 闭包作为参数的多种写法

在函数签名中,使用 `where` 子句和直接在泛型参数后指定 Trait 约束是等价的,这两种写法都可以用来接收闭包作为参数.

**等价写法示例:**

```rust
// 使用 `where` 子句
fn exec_<'a, F>(mut f: F)
where
    F: FnOnce(&'a str) -> String,
{
    f("hello");
}

// 直接在泛型参数后指定
fn exec<'a, F: FnOnce(&'a str) -> String>(mut f: F) {
    f("hello");
}
```

---

### 2. 闭包作为参数的复杂示例

此示例展示了如何将不同类型的闭包(有参数、无参数)作为函数参数,以及闭包如何处理泛型和枚举类型.

```rust
// 定义一个接受无参数闭包的函数
fn no_argu_func<F>(f: F)
where
    F: Fn(), // F 必须是一个无参数、无返回值的 Fn 闭包
{
    f();
}

// 定义一个函数,它接受一个闭包作为参数,并传递参数给闭包,然后返回闭包的执行结果
fn argu_func<'a, T, F>(f: F, name: &'a str, age: usize, sex: &'a str, score: T) -> Info<'a, T>
where
    // F 是一个 Fn 闭包,其参数和返回值类型都已明确定义
    F: Fn(&'a str, usize, &str, T) -> Info<'a, T>,
{
    f(name, age, sex, score)
}

fn main() {
    // 闭包与函数都可以作为参数传递给 no_argu_func
    let closure = || println!("I'm a closure!");
    no_argu_func(closure);

    fn function() {
        println!("I'm a function!");
    }
    no_argu_func(function);

    // 有参数的闭包示例
    let get_score1_info = |name: &str, age: usize, sex: &str, score: f64| {
        // ... (省略部分代码)
        Info::Score(score)
    };
    let info1 = argu_func(get_score1_info, "Sharon", 20, "female", 99.9);
    match info1 {
        Info::Score(score) => println!("成功捕获浮点数"),
        _ => println!("错误"),
    }
}
```

---

### 3. 闭包类型的判断与 `Fn` Trait

闭包的类型(`Fn`、`FnMut`、`FnOnce`)由其内部对**捕获变量**的操作决定.

- **`Fn`**:闭包只对捕获变量进行不可变借用(`&`),可以被多次调用.
- **`FnMut`**:闭包对捕获变量进行可变借用(`&mut`),可以被多次可变调用.
- **`FnOnce`**:闭包会**消耗**捕获变量的所有权,因此只能被调用一次.

**代码分析:**

在 `main` 函数中的 `diary` 闭包,它的类型判断遵循以下逻辑:

```rust
let mut farewell = "goodbye".to_owned();

let diary = || {
    let greeting = "hello";

    // 1. 打印 `greeting`:对 `greeting` 进行不可变借用,要求 `Fn`.
    println!("I said {}.", greeting);

    // 2. 修改 `farewell`:对 `farewell` 进行可变借用,要求 `FnMut`.
    farewell.push_str("!!!");

    // 3. 消耗 `farewell`:调用 `mem::drop` 会消耗 `farewell` 的所有权,要求 `FnOnce`.
    mem::drop(farewell);
};
```

`diary` 闭包最终实现了所有操作所需的**最严格的 Trait**,也就是 **`FnOnce`**.因为一个 `FnOnce` 闭包可以执行所有 `Fn` 和 `FnMut` 的操作,所以它能顺利地传递给 `apply` 函数,因为 `apply` 也要求闭包是 `FnOnce` 类型.

而 `double` 闭包 `let double = |x| 2 * x;` **没有捕获任何外部变量**,它只使用了自己的参数 `x`.因此,它不需要借用或消耗任何外部数据,其类型为最宽松的 **`Fn`**.

---

### 4. 返回闭包的两种方式

当函数需要返回一个闭包时,我们不能直接写出闭包的匿名类型.Rust 提供了两种常见的方法来解决这个问题:

#### 方式一:使用 `impl Trait`(静态分发)

使用 `impl Fn(...)` 语法,编译器在编译时会为我们推断出具体的闭包类型.这种方式要求函数的所有返回路径都返回**同一类型**的闭包.

**示例:**

```rust
fn create_fn() -> impl Fn(i32) -> i32 {
    let num = 5;
    // 这里只创建一个闭包实例
    let closure = move |x| x + num;
    closure
}

fn factory_(x: i32) -> impl Fn(i32) -> i32 {
    let num = 5;
    // 因为 if 和 else 语句会创建两个独立的闭包实例,
    // 所以必须在 if 之前创建一个闭包实例,以确保返回类型一致.
    let closure = move |x| x + num;
    closure
}
```

#### 方式二:使用 `Box<dyn Trait>`(动态分发)

如果你的函数需要根据不同条件返回**不同类型**的闭包(即使代码看起来一样),你可以使用 `Box<dyn Fn(...)>`.

- `dyn Trait` 表示一个“Trait 对象”,它允许你在运行时使用实现了该 Trait 的任何类型.
- `Box` 是一个智能指针,它将闭包存储在堆上,解决了 `dyn` Trait 的大小不确定性问题.

**示例:**

```rust
fn factory(x: i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1 {
        // 返回一个被 Box 包装的闭包实例
        Box::new(move |x| x + num)
    } else {
        // 返回另一个被 Box 包装的闭包实例
        Box::new(move |x| x + num)
    }
}
```

尽管 `if` 和 `else` 分支中的闭包是不同的匿名类型,但它们都被 `Box` 统一包装成了 **`Box<dyn Fn(i32) -> i32>`** 类型,这使得函数能够成功编译.这种方法提供了灵活性,但会带来轻微的性能开销.
