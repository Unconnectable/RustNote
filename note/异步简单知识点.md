# 异步编程的简单知识点

## 基本概念

各种类型如何协同工作:

1. **CPU 密集型任务**:最适合使用**线程池**来执行.将任务提交到线程池,线程池中的线程数量与 CPU 核心数匹配,以确保每个核心都得到充分利用,但又不会因为线程过多而导致性能下降.
2. **I/O 密集型任务**:这是**异步运行时**大放异彩的领域.异步运行时通过事件循环和非阻塞 I/O,可以在一个线程中高效地管理成千上万个并发连接.当一个 I/O 任务在等待时,该线程可以立即切换去处理另一个已经就绪的任务.
3. **异步运行时与线程池的结合**:在实际应用中,这两者常常结合使用.虽然异步运行时非常擅长处理 I/O 密集型任务,但当一个异步任务中包含了**CPU 密集型**的子任务时,它不能在主事件循环线程中执行,因为这会阻塞整个事件循环,导致所有其他 I/O 任务都无法处理.
   - **解决方案**:将这个 CPU 密集型子任务**提交给一个单独的线程池**.异步运行时将任务从主线程“卸载”到线程池中去执行.当线程池中的线程完成计算后,再通过回调或消息的方式通知异步运行时,使其能够继续执行后续的 I/O 操作.

**总结一下:**

- **CPU 密集型**是任务的类型,它的瓶颈在 CPU.
- **I/O 密集型**是任务的类型,它的瓶颈在 I/O.
- **线程池**是一种管理和复用线程的机制,它可以用于高效地处理 CPU 密集型任务,也可以通过增加线程数量来处理 I/O 密集型任务.
- **异步运行时**是一种专门为 I/O 密集型任务设计的并发模型,它通过非阻塞 I/O 来提高 I/O 任务的吞吐量.

它们并非互斥,而是一种互补关系.现代高性能的并发框架通常会结合使用这两种模型,利用异步运行时来高效处理海量的 I/O 操作,同时使用线程池来处理那些耗时的 CPU 密集型计算,从而实现整体性能的最优化.

## `python`的一个例子 容易理解

```python
import asyncio
import time

# async 定义了一个协程函数
async def task_one():
    print("任务一:开始等待 2 秒...")
    # await 暂停,等待 asyncio.sleep(2) 完成
    await asyncio.sleep(2)
    print("任务一:等待结束,完成！")

# async 定义了另一个协程函数
async def task_two():
    print("任务二:开始等待 1 秒...")
    # await 暂停,等待 asyncio.sleep(1) 完成
    await asyncio.sleep(1)
    print("任务二:等待结束,完成！")

# async 定义了主入口
async def main():
    start_time = time.time()

    # asyncio.gather() 并发运行多个协程
    await asyncio.gather(
        task_one(),
        task_two()
    )

    end_time = time.time()
    print(f"所有任务都完成了！总共耗时:{end_time - start_time:.2f} 秒.")

# 运行主协程
if __name__ == "__main__":
    asyncio.run(main())
```

输出结果

```sh
任务一:开始等待 2 秒...
任务二:开始等待 1 秒...
任务二:等待结束,完成！
任务一:等待结束,完成！
所有任务都完成了！总共耗时:2.00 秒.
```

`asyncio.gather()` 会**按照提供的顺序启动任务**.

1. 当调用 `await asyncio.gather(task_one(), task_two())` 时,事件循环会先启动 `task_one`.
2. `task_one` 开始执行,打印出 "开始..." 的信息.
3. 然后,它遇到了 `await asyncio.sleep(2)`.这是一个**非阻塞操作**,因为它需要等待外部资源(时间)而不是 CPU.
4. 此时,`task_one` **暂停**,并将控制权交还给事件循环.
5. 事件循环发现 `task_one` 正在等待,于是它立即**继续**,去启动 `gather` 中队列里的下一个任务,也就是 `task_two`.
6. `task_two` 开始执行,打印出 "开始..." 的信息.
7. 它遇到了 `await asyncio.sleep(1)`,同样暂停并交出控制权.

所以,虽然两个任务的启动是有顺序的,但它们一旦遇到 `await`,就会立即**把执行权让给下一个“准备好”的任务**.

异步编程的精髓:**当一个任务需要等待时,它不会“霸占”着程序,而是主动让出位置,让其他任务可以利用这段空闲时间去运行**.这个过程称为**协程的协作式多任务**(Cooperative Multitasking of Coroutines).
