## 智能指针概念表格

| 类型/概念          | 核心功能                                | 线程安全 (`Send`/`Sync`)            | 典型用例                                              |
| ------------------ | --------------------------------------- | ----------------------------------- | ----------------------------------------------------- |
| **`Cell<T>`**      | **单线程**内部可变性 (仅限 `Copy` 类型) | 否                                  | 在单线程中,对 `Copy` 类型的资料进行简单的内部修改     |
| **`RefCell<T>`**   | **单线程**内部可变性 (运行时检查)       | 否                                  | 在单线程中,对非 `Copy` 类型的资料进行内部可变借用     |
| **`Rc<T>`**        | **单线程**共享所有权                    | 否                                  | 在单线程中,多个部分需要共享资料的所有权 (如树状结构)  |
| **`Arc<T>`**       | **多线程**共享所有权 (`Atomic`)         | **是**                              | 在多线程中,多个线程需要共享资料的所有权               |
| **`Mutex<T>`**     | 多线程互斥可变性                        | **是**                              | 在多线程中,安全地修改共享资料                         |
| **`Weak<T>`**      | 解决循环引用                            | 取决于其 `Rc` 或 `Arc`              | 在树状结构中,子节点指向父节点,避免内存泄漏            |
| **`Box<T>`**       | 堆上所有权 (单独拥有)                   | 是                                  | 将大型资料或递归类型存储在堆上,或作为简单的拥有型指针 |
| **`&` 和 `&mut`**  | 引用和借用                              | 是                                  | 在不转移所有权的情况下,安全地读取或修改资料           |
| **`Lifetimes`**    | 编译时确保引用有效性                    | N/A (编译器机制)                    | 确保引用不会比其指向的资料活得更久,防止悬垂指针       |
| **`Raw Pointers`** | `unsafe` 的裸指针                       | N/A (不受 LocalThread 安全系统管理) | 与 C 语言接口 (FFI) 交互,或手动管理内存的底层实现     |
| **`RwLock<T>`**    | **多线程**读写锁                        | **是**                              | 读操作远多于写操作的多线程场景                        |

---

## 基本多线程知识

### `thread::spawn` 与 `join()` 的使用

`thread::spawn` 用于创建一个新的线程.`join()` 的作用是阻塞主线程,使其等待所有子线程执行完毕后再结束.否则,主线程可能会提前结束,导致子线程意外终止.

`join()` 在代码中的不同位置会产生不同的输出:

1. **在 `loop` 之前阻塞**:主线程会等待子线程全部完成后才开始自己的循环.

   ```sh
   hi number 1 from the spawned thread!
   hi number 2 from the spawned thread!
   hi number 3 from the spawned thread!
   hi number 4 from the spawned thread!
   hi number 11 from the main thread!
   hi number 12 from the main thread!
   hi number 13 from the main thread!
   hi number 14 from the main thread!
   ```

2. **在 `loop` 之后阻塞**:子线程和主线程的输出会并发执行.

   ```rust
   use std::thread;
   use std::time::Duration;

   fn main() {
       let handle = thread::spawn(|| {
           for i in 1..5 {
               println!("hi number {} from the spawned thread!", i);
               thread::sleep(Duration::from_millis(1));
           }
       });

       handle.join().unwrap();

     //loop
       for i in 1..5 {
           println!("hi number {} from the main thread!", i + 10);
           thread::sleep(Duration::from_millis(1));
       }
       //handle.join().unwrap();
   }
   ```

### 线程间所有权转移:`move` 关键字

在新线程中使用来自其他线程的变量时,如果变量被提前销毁,就会导致内存不安全.通常,我们使用 **`move` 关键字**来将变量的所有权移动到新线程中.

LocalThread

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", &v);
    });

    handle.join().unwrap();

    // 下面代码会报错:borrow of moved value: `v`
    // println!("{:?}",v);
}
```

---

### 并发的哈希表

这段代码展示了如何使用 `Arc<Mutex<T>>` 来构建一个线程安全的哈希表,并进行并发读写操作.

LocalThread

```rust
use rand::{Rng, thread_rng};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;

// 这是一个用于多线程共享的哈希表结构体.
struct MyHashTable {
    data: Mutex<HashMap<u32, u32>>,
}

impl MyHashTable {
    fn new() -> Self {
        MyHashTable {
            data: Mutex::new(HashMap::new()),
        }
    }

    fn set_item(&self, key: u32, value: u32) {
        let mut data = self.data.lock().unwrap();
        data.insert(key, value);
    }
}

/// 并发地向哈希表中添加元素.
///
/// # 参数
/// * `num_threads` - 要创建的线程数量.
/// * `adds_per_thread` - 每个线程向哈希表中添加的元素数量.
fn run_concurrent_hash_table_benchmark(num_threads: usize, adds_per_thread: u32) {
    let ht = Arc::new(MyHashTable::new());
    let mut handles = vec![];

    for _ in 0..num_threads {
        let ht_clone = Arc::clone(&ht);

        let handle = thread::spawn(move || {
            for _ in 0..adds_per_thread {
                // 使用 gen_range 来生成 u32 类型的随机数
                let mut rng = thread_rng();
                let key = rng.gen_range(u32::MIN..u32::MAX);
                let value = rng.gen_range(u32::MIN..u32::MAX);
                ht_clone.set_item(key, value);
            }
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(
        "所有线程完成.总共添加了 {} 个元素.",
        ht.data.lock().unwrap().len()
    );
}

fn main() {
    run_concurrent_hash_table_benchmark(10, 1_000_00);
}
```

---

### `main` 线程与子线程的差异

下表比较了由 `main` 函数创建的子线程,与其他普通线程创建的子线程之间的区别.

| 特性                    | 由 `main` 函数创建的子线程                                                                      | 由其他普通线程创建的子线程                                                     |
| ----------------------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **生命周期依赖**        | 最终依赖于整个**进程**的生命周期.当 `main` 函数执行完毕,整个进程终止,所有线程都会被强制终止.    | 最终也依赖于整个**进程**的生命周期,与主线程相同.                               |
| **与父线程的关系**      | 即使 `main` 函数中的代码 (在 `join` 之前) 已经执行完毕,子线程仍会继续独立运行,直到整个进程结束. | 与其父线程的生命周期是**独立的**.父线程的终止不会自动导致其创建的子线程也终止. |
| **句柄 (`JoinHandle`)** | 可以选择保存 `JoinHandle`,并使用 `join()` 来同步主线程的执行,使其等待子线程完成.                | 也可以保存 `JoinHandle`,并用 `join()` 来同步其父线程的执行.                    |
| **管理机制**            | 作为整个程序的入口,主线程是**所有线程的共同载体**.                                              | 仅仅是一个普通的执行单元.                                                      |

匯出到試算表

---

### 子线程的生命周期

如果子线程中的代码没有执行完会怎样?这可以分为两种情况讨论:

1. **IO 阻塞型任务**:线程的任务是一个循环 IO 读取,例如网络服务.IO 阻塞会使线程大部分时间处于睡眠状态,CPU 占用很小.当收到结束信号(如 socket 关闭)时,线程才会结束.

   LocalThread

   ```rust
   use std::io::{self, BufRead};
   use std::thread;
   use std::time::Duration;

   fn main() {
       println!("主线程:即将创建一个 IO 阻塞线程...");

       // 创建一个线程,它会等待用户输入
       let io_thread = thread::spawn(|| {
           println!("IO 线程:正在等待键盘输入(IO 阻塞中...).输入 'quit' 结束.");

           // 创建一个标准输入读取器
           let stdin = io::stdin();

           // 循环读取每一行输入
           for line in stdin.lock().lines() {
               let line = line.unwrap();

               // 打印读取到的数据
               println!("IO 线程:读到一行数据 -> {}", line);

               // 如果用户输入 'quit',则跳出循环,结束线程
               if line.trim().eq_ignore_ascii_case("quit") {
                   println!("IO 线程:收到结束信号,即将终止.");
                   break;
               }
           }
       });

       // 主线程继续执行其他任务
       println!("主线程:IO 线程已创建,我将继续执行...(模拟其他工作)");
       thread::sleep(Duration::from_millis(100));
       println!("主线程:我的工作已完成.现在等待 IO 线程结束.");

       // 等待 IO 线程完成
       io_thread.join().unwrap();
       println!("主线程:IO 线程已成功结束,程序退出.");
   }
   ```

2. **无限循环型任务**:线程的任务是一个没有任何阻塞或休眠的循环.此时 CPU 会被跑满,如果未设置终止条件,该线程将持续占用一个 CPU 核心,直到整个进程结束.

   LocalThread

   ```rust
   use std::thread;
   use std::time::Duration;
   fn main() {
       // 创建一个线程A
       let new_thread = thread::spawn(move || {
           // 再创建一个线程B
           thread::spawn(move || {
               loop {
                   println!("I am a new thread.");
               }
           })
       });

       // 等待新创建的线程执行完成
       new_thread.join().unwrap();
       println!("Child thread is finish!");

       // 睡眠一段时间,看子线程创建的子线程是否还在运行
       thread::sleep(Duration::from_millis(100));
   }
   ```

---

### 同步:`std::sync::Barrier`

`Barrier` 是用于多线程同步的工具,它让多个线程在一个特定的"同步点"上集合.可以把它想象成一个等待所有队员到齐后才能开跑的接力赛起点.

#### `Barrier` 的方法

- **`Barrier::new(n)`**:创建一个新的 `Barrier` 实例,参数 `n` 表示需要有多少个线程才能解除屏障.
- **`barrier.wait()`**:让当前线程进入等待状态,直到屏障解除.当最后一个线程调用 `wait()` 时,所有等待的线程都会被唤醒并继续执行.

#### 示例:

如果 `Barrier` 的计数为 6,但只有 5 个线程调用了 `wait()`,那么这 5 个线程将永远被阻塞.

LocalThread

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let mut handles = Vec::with_capacity(6);
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        let b = barrier.clone();
        handles.push(thread::spawn(move || {
            println!("before wait");
            b.wait();
            println!("after wait");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

---

### 线程局部存储:`thread_local!`

`thread_local!` 宏用于定义线程局部变量.这意味着每个线程都会拥有该变量的一个独立拷贝,不同线程之间无法共享或修改彼此的拷贝.

LocalThread

```rust
use std::cell::RefCell;
use std::thread;

struct LocalThread;
impl LocalThread {
    thread_local! {
        static TH_L:RefCell<usize>  =RefCell::new(2);
    }
}
// 使用 thread_local! 宏定义一个线程局部变量.
// 每个线程都会拥有 FOO 的一个独立拷贝,其初始值都为 1.
thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

fn main() {
    // ----------------------------------------------------
    // 主线程对 FOO 的操作
    // ----------------------------------------------------
    println!("主线程开始...");

    // 在主线程中,获取 FOO 的值.
    FOO.with(|f| {
        // 断言其初始值是 1.
        println!("主线程中 FOO 的初始值为: {}", *f.borrow());
        assert_eq!(*f.borrow(), 1);

        // 修改主线程中 FOO 的值为 2.
        *f.borrow_mut() = 2;
        println!("主线程中 FOO 的值已修改为: {}", *f.borrow());
    });

    // ----------------------------------------------------
    // 子线程对 FOO 的操作
    // ----------------------------------------------------
    // 创建一个新线程.
    let t = thread::spawn(move || {
        println!("\n子线程开始...");

        // 子线程会得到它自己独立的 FOO 拷贝,其初始值仍为 1.
        FOO.with(|f| {
            // 断言初始值是 1,这与主线程的修改无关.
            println!("子线程中 FOO 的初始值为: {}", *f.borrow());
            assert_eq!(*f.borrow(), 1);

            // 修改子线程中 FOO 的值为 3.
            *f.borrow_mut() = 99999;
            println!("子线程中 FOO 的值已修改为: {}", *f.borrow());
        });
    });

    // 等待子线程完成.
    t.join().unwrap();
    println!("\n子线程已完成.");

    // ----------------------------------------------------
    // 验证主线程的值
    // ----------------------------------------------------
    println!("回到主线程...");

    // 再次在主线程中获取 FOO 的值.
    FOO.with(|f| {
        // 尽管子线程将其拷贝修改为了 3,主线程的值仍然是 2.
        println!("主线程中 FOO 的最终值为: {}", *f.borrow());
        assert_eq!(*f.borrow(), 2);
    });

    println!("断言成功,程序正常结束.");

    println!("\n以下是结构体的局部 thread\n");
    LocalThread::TH_L.with(|f| {
        println!("默认的值为: {:?}", f);
    });
    let t: thread::JoinHandle<()> = thread::spawn(move || {
        LocalThread::TH_L.with(|f| {
            println!("初始值为: {:?}", f);
            *f.borrow_mut() = 100;
            println!("局部修改 f 的值为: {:?}", f);
            assert_eq!(*f, 100.into());
        });
    });
    t.join().unwrap();

    LocalThread::TH_L.with(|f| {
        println!("子线程修改后的值为: {:?}", f);
        *f.borrow_mut() = 999;
        assert_eq!(*f, 999.into());
    });
    LocalThread::TH_L.with(|f| {
        println!("主线程修改后的值为: {:?}", f);
        assert_eq!(*f, 999.into());
    });
}
```

---

### 局部条件 `Condvar`

当一个新线程被创建时,它需要拥有它所操作的数据,因此需要使用 `move` 关键字.如果多个线程(如子线程和主线程)需要同时对同一个变量进行操作,那么这个数据必须能够在线程间安全地共享.

LocalThread

```rust
use std::sync::{Arc, Condvar, Mutex};
use std::thread::{self};
fn main() {
    //
    let pair = Arc::new((Mutex::new(false), Condvar::new()));

    let thread_pair = pair.clone();

    thread::spawn(move || {
        let (pair_lock, pair_condvar) = &*thread_pair;
        let mut started = pair_lock.lock().unwrap();
        println!("child proc get the lcok");
        *started = true;
        println!("child proc is notifying the main thread");
        pair_condvar.notify_all();
    });

    let (lock_, condvar) = &*pair;
    let mut started = lock_.lock().unwrap();
    // 如果 started 是 false,也就是默认的值,这意味着当前的子线程还没有修改
    while !*started {
        // 释放当前 main 线程持有的锁,等待 child thread
        started = condvar.wait(started).unwrap();
    }
}
```

### 关键方法讲解

- **`lock_pair.lock().unwrap()`**
  - `lock()`:尝试获取互斥锁.如果锁已被持有,调用线程将进入**阻塞**状态,直到锁被释放.
  - `unwrap()`:用于处理 `lock()` 可能因线程 panic 而失败的情况.
- **`cvar.notify_one()`**
  - 此方法会**唤醒**一个正在等待该条件变量的线程.如果多个线程在等待,操作系统会选择其中一个.
- **`cvar.wait(started).unwrap()`**
  - 这是 `Condvar` 的核心方法,用于让线程等待一个条件.它会原子性地完成三个操作:
    1. **释放锁**:立即释放传入的 `MutexGuard`,当前线程进入**睡眠**状态,等待通知.
    2. **重新获取锁**:一旦被唤醒,线程会进入**阻塞**状态,尝试重新获取互斥锁.
    3. **返回**:当成功获取锁后,`wait()` 方法才会返回.

---

### 只执行一次的函数

`std::sync::Once` 确保了在多线程环境下,一个函数(或闭包)只会被调用一次.

LocalThread

```rust
use std::sync::Once;
use std::thread;

static mut VAL: usize = 0;
static INIT: Once = Once::new();

fn main() {
    let handle1 = thread::spawn(move || {
        INIT.call_once(|| unsafe {
            VAL = 1;
        });
    });

    let handle2 = thread::spawn(move || {
        INIT.call_once(|| unsafe {
            VAL = 2;
        });
    });
    let handle3 = thread::spawn(move || {
        INIT.call_once(|| unsafe {
            VAL = 2;
        });
    });
    handle1.join().unwrap();
    handle2.join().unwrap();
    handle3.join().unwrap();
    println!("{}", unsafe { VAL });
}
```

#### `call_once()` 的执行逻辑

`call_once()` 方法接受一个闭包作为参数.`Once` 实例的内部状态保证了,**无论 `call_once()` 在多少个线程中被调用,它的闭包只会被其中一个线程成功执行一次**.

- **第一个线程**:假设 `handle1` 首先运行,它调用 `INIT.call_once()`.由于 `INIT` 状态为"未执行",它会执行闭包,将 `VAL` 设为 `1`,然后将状态标记为"已执行".
- **后续线程**:当 `handle2` 和 `handle3` 随后调用 `INIT.call_once()` 时,它们会发现 `INIT` 的状态已经是"已执行",于是会**立即返回**,而不会去执行各自的闭包.

**代码运行的结果取决于哪个线程先调用 `INIT.call_once`**.最终 `VAL` 的值可能是 `1` 或 `2`,但只会是其中一个,永远不会出现同时赋值的竞态条件.

## 线程间的消息传递 :使用`Mutex`和`Condvar`

### 最基本的`channel`用法

```rust

use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个消息通道, 返回一个元组:(发送者,接收者)
    let (tx, rx) = mpsc::channel();

    // 创建线程,并发送消息
    thread::spawn(move || {
        // 发送一个数字1, send方法返回Result<T,E>,通过unwrap进行快速错误处理
        tx.send(1).unwrap();

        // 下面代码将报错,因为编译器自动推导出通道传递的值是i32类型,那么Option<i32>类型将产生不匹配错误
        // tx.send(Some(1)).unwrap()
    });

    // 在主线程中接收子线程发送的消息并输出
    println!("receive {}", rx.recv().unwrap());
}
```

注意点:

- `send()` 方法返回一个 `Result<(), SendError>` 类型
- `rx.recv().unw rap()`: `recv()` 是一个 **阻塞(blocking)** 方法.如果通道中没有可用的消息,调用 `recv()` 的线程会一直等待,直到有消息被发送过来 这里也就是`main`线程会一直等待直到子线程的 tx 吧消息发送过来

使用非阻塞的方法`try_recv` ,此时会尝试接受一个值,如果失败的话会给出空的提示,下面的例子说明了 很可能在子线程发送消息前 rx 已经尝试 接受值 ,但是此时没有 于是会给出空的提示
为了解决 ,应该在创建子线程后 使用 join 进行同步,如果在 println 后使用 join,依然会得到空的输出

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let handle = thread::spawn(move || {
        tx.send(1).unwrap();
    });

    handle.join().unwrap();
    println!("receive {:?}", rx.try_recv());
    println!("receive {:?}", rx.try_recv());
    //handle.join().unwrap();
}
```

### 使用条件变量和互斥锁的例子

```rust
use std::sync::{Arc, Condvar, Mutex};
use std::thread::{sleep, spawn};
use std::time::Duration;
fn main() {
    let flag: Arc<Mutex<bool>> = Arc::new(Mutex::new(false));
    let condvar: Arc<Condvar> = Arc::new(Condvar::new());
    let cflag: Arc<Mutex<bool>> = flag.clone();
    let c_condvar: Arc<Condvar> = condvar.clone();

    let handle = spawn(move || {
        //子线程尝试获取锁 修改flag
        let mut lock = cflag.lock().unwrap();
        let mut cnt = 0;
        while cnt < 3 {
            while !*lock {
                lock = c_condvar.wait(lock).unwrap();
            }
            *lock = false;
            cnt += 1;
            println!("inner cnt :{}", cnt);
        }
    });
    handle.join().unwrap();
    let mut cnt = 0;
    loop {
        sleep(Duration::from_millis(500));
        *flag.lock().unwrap() = true;
        cnt += 1;
        if cnt > 3 {
            break;
        }
        println!("outside cnt: {}", cnt);
        condvar.notify_one();
    }

    println!("{:?}", flag);
}
```

#### 对以上代码的详细解释

代码的流程如下:

- **资源与锁分离**:共享的资源(`flag`)被封装在 **`Mutex` (互斥锁)** 中.`Mutex` 的职责是确保在任何给定时刻,只有一个线程能够安全地访问和修改这个资源,从而避免数据竞争.
- **流程与条件变量协作**:多线程的运行流程存在一种**依赖关系**(`step2` 依赖于 `step1`).仅仅使用 `Mutex` 是不够的,它只能防止数据竞争,但无法协调线程的执行顺序.
  - **`Condvar` (条件变量)** 的职责是解决这种**流程依赖**.它就像一个协调员,允许线程在条件不满足时高效地"挂起"(`wait`),并在条件被其他线程改变后,被"通知"并"唤醒"(`notify_one`).

这段代码构成了典型的**生产者-消费者**模型.主线程是**生产者**,它负责生成"任务"(将 `flag` 设为 `true`);子线程是**消费者**,它负责处理"任务"(将 `flag` 设为 `false`).`Condvar` 在它们之间扮演了"信号量"的角色,当有新任务时发出信号,当没有任务时则让消费者等待.

并且因为同时都要获取`flag`这个变量,需要使用互斥锁进行加锁,又子线程的消费依赖 `main` 线程的生产,因此使用条件变量进行线程间的通知和交互.  
当 `main` 线程没有生产的时候,子线程需在不满足条件的时候使用`wait()`方法传入当前获取的`lock`,释放对锁的持有,当前的子线程进行休眠直到 `main` 线程通过`notify_one()`通知子线程,这个时候会重新醒来完成它的消费工作

### 休眠和阻塞的区别总结

| 特性         | 休眠 (Sleeping)                        | 阻塞 (Blocking)                               |
| ------------ | -------------------------------------- | --------------------------------------------- |
| **主被动**   | **主动行为**:由程序代码调用.           | **被动行为**:由操作系统决定,因为资源不可用.   |
| **目的**     | 延迟执行,等待**预设时间**.             | 等待某个**事件或资源**.                       |
| **持续时间** | **固定**,由参数决定.                   | **不确定**,取决于外部条件.                    |
| **常见场景** | 模拟延迟、定时任务、避免 CPU 占用过高. | 获取互斥锁、I/O 操作、调用 `Condvar::wait()`. |

## 原子操作
