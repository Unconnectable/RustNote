```rust
use std::collections::HashMap;

fn main() {
    let mut map: HashMap<String, i32> = HashMap::new();
    // map 是一个空的 HashMap，键类型为 String，值类型为 i32
}
```

注意到`entry().or_insert()`返回的是一个&mut T 的可变引用 不能同时存在两个可变引用 于是可以这样

```rust
let v1 = Grils.entry("Lydia7").or_insert("Beautiful").clone();
let v2 = \*Grils.entry("Sharon").or_insert("Beautiful");
```

```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert("Blue", 10);

    // 覆盖已有的值
    let old = scores.insert("Blue", 20);
    assert_eq!(old, Some(10));

    // 查询新插入的值
    let new = scores.get("Blue");
    assert_eq!(new, Some(&20));

    //注意到`entry().or_insert()`返回的是一个&mut T的可变引用 不能同时存在两个可变引用 于是可以这样

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry("Yellow").or_insert(5);
    assert_eq!(*v, 5); // 不存在，插入5

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry("Yellow").or_insert(50);
    assert_eq!(*v, 5); // 已经存在，因此50没有插入

    let mut Grils = HashMap::new();
    Grils.insert("Sharon", "Lover");
    Grils.insert("Kelly", "Slave");
    let v1 = Grils.entry("Lydia7").or_insert("Beautiful").clone();
    let v2 = Grils.entry("Sharon").or_insert("Beautiful");
    println!("v1: {:#?} v2:{:#?}", v1, v2);
}
```
