## match 的用法

### 对任意 Some 包裹进行匹配

注意下面这段代码的`match`部分,由于 x 的值是`Some(5)`,所以会匹配到第二个分支`Some(y)`,这里 y 是新的变量,因为这里满足了匹配,所以会那拿走 x 被 Some 包裹的一切,也就是 5,于是 match 里面的 y 的值是 5

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

```sh
Matched, y = 5
at the end: x = Some(5), y = 10
```

### 对范围进行匹配

这里如果不是`1..=5`的话代表的是左闭右开的区间`[a,b)`

```rust
fn main() {
    let x = 5;

    match x {
        1..5 => println!("one through five"),
        _ => println!("something else"),
    }
}

// output
something else
```

字符范围的例子

```rust
fn main() {
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }
}

// output
early ASCII letter
```

## 从`if let`到`let else`的用法

其中 `let Ok(count) = u64::from_str(count_str)`将字符串解析为数字,是可能失败的,比如`"hello"`解析为`u64`的情况

于是返回的是一个`Result<u64, ParseIntError>`,还需要`Ok`或者`Err`解包

```rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    // error: `else` clause of `let...else` does not diverge
    // let Ok(count) = u64::from_str(count_str) else { 0 };
    (count, item)
}

fn let_else(s: &str) -> (u64, &str) {
    // it的类型是 Split<'_, &'static str>
    let mut it = s.split(", ");
    // 通过it.next()获取迭代器的下一个元素
    // 通过let else语法来处理Option类型的值
    let (Some(str_len), Some(item)) = (it.next(), it.next()) else {
        panic!("Error");
    };
    let Ok(len) = u64::from_str(str_len) else {
        panic!("Error parsing integer to ");
    };
    (len, item)
}
fn main() {
    assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
    let (len, temp_str) = let_else("1000, Sharon");
    dbg!(len, temp_str);
}
```

###

`@` 操作符的用法

```rust

// 修复错误
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  3..=7,
        } => println!("id 值的范围在 [3, 7] 之间: {}", id),
        Message::Hello { id: newid@10 | 11 | 12 } => {
            println!("id 值的范围在 [10, 12] 之间: {}", newid)
        }
        Message::Hello { id } => println!("Found some other id: {}", id),
    }
}
```

```sh
11 | ...ln!("id 值的范围在 [3, 7] 之间: {}", id),
   |                                         ^^ not found in this scope
   |
help: consider importing this function
   |
1  + use std::process::id;
```

这里的 id 本来是对范围变量的匹配,但是被编译器认成了`use std::process::id`,需要使用`@`对变量进行绑定

```rust
match msg {
    Message::Hello { id: newid @ 3..=7 } => println!("id 值的范围在 [3, 7] 之间: {}", newid),
    Message::Hello { id: newid @ (10 | 11 | 12) } => {
        println!("id 值的范围在 [10, 12] 之间: {}", newid)
    }
    Message::Hello { id } => println!("Found some other id: {}", id),
}
```
