### 1.

警告变量问题
`let y = 5;`会被警告未使用的变量，但是加上了下划线后的`let _x = 4;`则不会

```rust
fn main() {
    let _x = 4;
    let y = 5;
}
```

转换类型和`parse`解析的手法
`let guess = "42".parse().expect("Not a number!");`会将字符串"42"转换为整数类型，如果转换失败则会触发 panic，需要手动指定类型或者在 parse 后面指定类型

```rust
fn main() {
    let x: u128 = "42".parse().expect("This will never touch");
    let guess = "42".parse::<i32>().expect("Not a number!");
}
```

安全的溢出处理方法，`.saturing_add`方法可以安全地处理整数溢出问题,如果加法超过会返回最大值，如果小于最小值则返回最小值，这样可以避免 panic 的发生。
同样的还有`.saturating_sub`、`.saturating_mul`等加减乘除等方法

```rust
fn main() {
    let x: u8 = 2;
    let y = x.saturating_add(33);
    println!("{}", y);
}
```





`ref` 和 `&`

**总结和对比：**

| 特性           | `match optional_point { Some(ref p) => ... }`                | `match &optional_point { Some(p) => ... }`                   |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **匹配对象**   | 值本身 (`Option<Point>`)                                     | 值的引用 (`&Option<Point>`)                                  |
| **模式**       | `Some(ref p)`                                                | `Some(p)`                                                    |
| **绑定类型**   | `p` 被绑定为 `&Point`                                        | `p` 被绑定为 `&Point`                                        |
| **所有权影响** | 不移动 `optional_point`                                      | 不移动 `optional_point`                                      |
| **何时使用**   | 当你匹配一个值，但想避免移动它，并希望获得其内部数据的引用时。 | 当你已经在处理一个引用，并且想通过模式匹配访问它所指向的数据的引用时。 |
